var _ = require('underscore');
var GB = require('lib/Goonbee/toolbox');

var storage = {
  users: {},
  chats: {}
};

var hashingFunction;

var p = {
  autoId: function(field, offset) {
    GB.requiredArguments(field);
    GB.requiredVariables(hashingFunction);
    offset = GB.optional(offset, 0);

    var candidate = hashingFunction(_.count(field) + offset);
    if (_.contains(field, candidate)) {
      return this(field, offset + 1);
    }
    else {
      return candidate;
    }
  },
  getCurrentDate: function() {
    return new Date().toISOString();
  },
  lazyChat: function(chatId, options) {
    GB.requiredArguments(options.owner);

    // attempt to get existing chat
    var chat = storage.chats[chatId];

    // lazily create it if it does not exist
    if (_.isUndefined(chat)) {
      // generate id for it if necessary
      chatId = GB.optional(chatId, p.autoId(storage.chats));

      // initialize it
      chat = {
        meta: {
          owner: options.owner,
          dateCreated: options.dateCreated || p.getCurrentDate(),
          name: options.name || null,
          topic: options.topic || null,
        },
        participants: [],
        messages: []
      };

      // commit it
      storage.chats[chatId] = chat;
    }

    // return either the original existing chat or the newly initialized and committed one
    return chat;
  }
};

var inMemoryPersistence = module.exports = {
  setHashingFunction: function(handler) {
    GB.requiredArguments(handler);

    hashingFunction = handler;
  },
  userExists: function(username) {
    GB.requiredArguments(username);

    return !_.contains(storage.users, username);
  },
  setUser: function(userId, username) {
    GB.requiredArguments(username);
    GB.requiredVariables(hashingFunction);
    
    // lazy creation of userId (and therewith user)
    if (_.isUndefined(userId)) userId = hashingFunction(_.count(storage.users));

    storage.users[userId] = username;

    return userId;//lm this one needs to be reflected in the thrift interface, i.e. this creates a new user if userId is not supplied
  },
  getUsername: function(userId) {
    GB.requiredArguments(userId);

    return storage.users[userId];
  },
  getUserCount: function() {
    return _.size(storage.users);
  },
  getChatStats: function(userId, chatId) {
    GB.requiredArguments(userId, chatId);
    var chat = p.lazyChat(chatId, {owner: userId});

    var stats = {
        messageCount: chat.messages.length,
        participantCount: chat.participants.length,
      };

    return stats;
  },
  getChatMeta: function(userId, chatId) {
    GB.requiredArguments(userId, chatId);
    var chat = p.lazyChat(chatId, {owner: userId});

    var meta = {
        owner: chat.meta.owner,
        dateCreated: chat.meta.dateCreated,
        name: chat.meta.name,
        topic: chat.meta.topic,
      };

    return meta;
  },
  setChatMeta: function(userId, chatId, options) {
    GB.requiredArguments(userId, options);
    var chat = p.lazyChat(chatId, {owner: userId});

    // make updates
    if (!_.isUndefined(options.owner)) chat.meta.owner = options.owner;
    if (!_.isUndefined(options.dateCreated)) chat.meta.dateCreated = options.dateCreated;
    if (!_.isUndefined(options.name)) chat.meta.name = options.name;
    if (!_.isUndefined(options.topic)) chat.meta.topic = options.topic;

    return chat.id;//lm this one needs to be reflected in the thrift interface, i.e. this creates a new chat if chatId is not supplied
  },
  getChat: function(userId, chatId) {
    GB.requiredArguments(userId, chatId);
    var chat = p.lazyChat(chatId, {owner: userId});

    var chatObject = {
      id: chat.id,
      meta: this.getChatMeta(chatId),
      stats: this.getChatStats(chatId)
    };

    return chatObject;
  },
  newMessage: function(userId, chatId, message) {
    GB.requiredArguments(userId, chatId, message);
    var chat = p.lazyChat(chatId, {owner: userId});

    // chat.messages.push(message);
  },
  messages: function(userId, chatId) {
    //lm TODO
  }
};

//lm make sure that all the calls that need userId are defined as such in thrift.... make the userId required

//lm make sure that these hold
//setting meta on nonexisting chat should make it
//getting messages on nonexsting chat should make it
//getting stats and meta on a nonexisting chat should make it
//chatId is optional and can be autogenerated, with basic clashing protection
//userId is required




// struct ChatStats {
//  1: i32 messageCount,
//  2: i32 participantCount,
// }

// struct ChatMeta {
//  1: string name,
//  2: string topic,
//  3: string dateCreated,
// }

// struct Chat {
//  1: string id,
//  2: ChatMeta meta,
//  3: ChatStats stats,
// }



/*

id: {
  meta: {
    owner,
    name,
    topic,
    dateCreated,
  },
  participants: [],
  messages: [],
}

*/